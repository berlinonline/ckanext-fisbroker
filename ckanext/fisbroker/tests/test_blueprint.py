# -*- coding: UTF-8 -*-
"""Test for ckanext.fisbroker.controller.py"""

import json
import logging
import pytest
from urllib.parse import urlparse

from ckan.common import c
from ckan.lib.base import config
from ckan.logic import NotAuthorized
from ckan.logic.action.update import package_update
from ckan.model.package import Package
from ckan.plugins import implements, SingletonPlugin
from ckan.tests import factories as ckan_factories

from ckanext.harvest.interfaces import IHarvester
from ckanext.spatial.tests.conftest import clean_postgis
from ckanext.fisbroker import HARVESTER_ID
import ckanext.fisbroker.blueprint as blueprint
from ckanext.fisbroker.blueprint import get_error_dict
import ckanext.fisbroker.exceptions as fb_exceptions 
from ckanext.fisbroker.tests import FisbrokerTestBase, base_context, FISBROKER_HARVESTER_CONFIG, FISBROKER_PLUGIN
from ckanext.fisbroker.tests.mock_fis_broker import INVALID_GUID

LOG = logging.getLogger(__name__)

class TestControllerHelper(object):
    '''Tests for controller code not directly related to reimporting (i.e., helper stuff).'''

    def test_unknown_error_code_raises_error(self):
        '''Requesting an unknown error code should lead to a ValueError.'''
        with pytest.raises(ValueError):
            get_error_dict(100)

    def test_known_error_code_returns_dict(self):
        '''Requesting a known error code should return a dict with members
           'message' and 'code', with the correct values.'''
        error_code = blueprint.ERROR_NOT_FOUND_IN_CKAN
        error_dict = get_error_dict(error_code)
        assert 'message' in error_dict
        assert 'code' in error_dict

        assert error_dict['message'] == fb_exceptions.ERROR_MESSAGES[error_code]
        assert error_dict['code'] == error_code

@pytest.mark.ckan_config('ckan.plugins', f"{HARVESTER_ID} {FISBROKER_PLUGIN} harvest dummyharvest")
@pytest.mark.usefixtures('with_plugins', 'clean_postgis', 'clean_db', 'clean_index')
class TestReimport(FisbrokerTestBase):
    '''Tests for controller code directly related to reimporting.'''
    _load_plugins = ('dummyharvest', )

    def test_reimport_api_must_request_json(self, app):
        '''If the request does not accept json content, the server should respond with an HTTP 400.'''
        response = app.get(
            '/api/harvest/reimport?id=dunk',
            status=400,
        )
        assert response.is_json
        assert response.json['error']['code'] == fb_exceptions.ERROR_WRONG_CONTENT_TYPE

    def test_reimport_api_requires_id(self, app):
        '''Requests to the reimport API require the presence of an 'id' parameter.'''
        response = app.get(
            '/api/harvest/reimport', 
            headers={'Accept': 'application/json'},
            status=400,
        )
        assert response.is_json
        assert response.json['error']['code'] == fb_exceptions.ERROR_MISSING_ID

    def test_reimport_api_unknown_package_id_fails(self, app):
        '''If the reimport is triggered via the API and the requested package id does not exist,
           the server should respond with an HTTP 404, and the response should have content type
           application/json.'''
        response = app.get(
            '/api/harvest/reimport?id=dunk', 
            headers={'Accept': 'application/json'},
            status=404)
        assert response.is_json
        assert response.json['error']['code'] == fb_exceptions.ERROR_NOT_FOUND_IN_CKAN

    def test_reimport_browser_triggers_redirect(self, app, base_context):
        '''If the reimport is triggered via the Browser (HTML is requested), the response should be a
           302 redirect to a specific URL.'''
        # unsuccessful request, /dataset/dunk does not exist:
        response = app.get(
            '/dataset/dunk/reimport',
            headers={'Accept': 'text/html'},
            extra_environ={'REMOTE_USER': base_context['user'].encode('ascii')},
            status=302,
            follow_redirects=False,
        )
        url = urlparse(response.location)
        assert url.path == "/dataset/dunk"

        # successful request:
        fb_dataset_dict, source, job = self._harvester_setup(FISBROKER_HARVESTER_CONFIG)
        job.status = 'Finished'
        job.save()
        package_update(base_context, fb_dataset_dict)
        package_id = fb_dataset_dict['id']
        response = app.get(
            f'/dataset/{package_id}/reimport',
            headers={'Accept': 'text/html'},
            extra_environ={'REMOTE_USER': base_context['user'].encode('ascii')},
            follow_redirects=False,
            status=302,
        )
        url = urlparse(response.location)
        assert url.path == f"/dataset/{package_id}"

    def test_can_only_reimport_harvested_packages(self, app):
        '''If we try to reimport an existing package that was not generated by a harvester, the response
           should be an HTTP 422, with an internal error code 5.'''
        non_fb_dataset_dict = ckan_factories.Dataset()
        package_id = non_fb_dataset_dict['id']
        response = app.get(
            f"/api/harvest/reimport?id={package_id}",
            headers={'Accept': 'application/json'},
            status=422,
        )
        assert response.is_json
        assert response.json['error']['code'] == fb_exceptions.ERROR_NOT_HARVESTED

    def test_can_only_reimport_fisbroker_packages(self, app, base_context):
        '''If we try to reimport an existing package that was generated by a harvester other than
           ckanext-fisbroker, the response should be an HTTP 422, with internal error code 6.'''
        harvester_config = {
            'title': 'Dummy Harvester' ,
            'name': 'dummy-harvester' ,
            'source_type': 'dummyharvest' ,
            'url' : "http://test.org/csw"
        }
        dataset_dict, source, job = self._harvester_setup(harvester_config)
        package_id = dataset_dict['id']
        response = app.get(
            f"/api/harvest/reimport?id={package_id}",
            headers={'Accept':'application/json'},
            status=422,
        )
        assert response.is_json
        assert response.json['error']['code'] == fb_exceptions.ERROR_NOT_HARVESTED_BY_FISBROKER

    def test_can_only_reimport_with_guid(self, app, base_context):
        '''If we cannot determine a FIS-Broker guid for the package we try to reimport 
           return an HTTP 500 with internal error code 7.'''

        fb_dataset_dict, source, job = self._harvester_setup(FISBROKER_HARVESTER_CONFIG, fb_guid=None)
        # datasets created in this way have no extras set, so also no 'guid'
        package_id = fb_dataset_dict['id']
        response = app.get(
            f"/api/harvest/reimport?id={package_id}",
            headers={'Accept':'application/json'},
            extra_environ={'REMOTE_USER': base_context['user'].encode('ascii')},
            status=500,
        )
        assert response.is_json
        assert response.json['error']['code'] == fb_exceptions.ERROR_NO_GUID

    def test_handle_no_connection_to_fisbroker(self, app, base_context):
        '''If the FIS-Broker service cannot be reached, return an HTTP 500 with internal
           error code 8.'''

        unreachable_config = {
            'title': 'Unreachable FIS-Broker Harvest Source' ,
            'name': 'unreachable-fis-broker-harvest-source' ,
            'source_type': HARVESTER_ID ,
            'url' : "http://somewhere.over.the.ra.invalid/csw"
        }
        fb_dataset_dict, source, job = self._harvester_setup(unreachable_config)
        package_update(base_context, fb_dataset_dict)
        package_id = fb_dataset_dict['id']
        response = app.get(
            f"/api/harvest/reimport?id={package_id}",
            headers={'Accept':'application/json'},
            extra_environ={'REMOTE_USER': base_context['user'].encode('ascii')},
            status=500,
        )
        assert response.is_json
        assert response.json['error']['code'] == fb_exceptions.ERROR_NO_CONNECTION

    def test_handle_not_found_fisbroker(self, app, base_context):
        '''If FIS-Broker service replies that no record with the given guid exisits, return an
           HTTP 404 with internal error code 9.'''

        fb_dataset_dict, source, job = self._harvester_setup(FISBROKER_HARVESTER_CONFIG, fb_guid='invalid_guid')
        package_update(base_context, fb_dataset_dict)
        package_id = fb_dataset_dict['id']
        response = app.get(
            f"/api/harvest/reimport?id={package_id}",
            headers={'Accept':'application/json'},
            extra_environ={'REMOTE_USER': base_context['user'].encode('ascii')},
            status=404,
        )
        assert response.is_json
        assert response.json['error']['code'] == fb_exceptions.ERROR_NOT_FOUND_IN_FISBROKER

    def test_successful_reimport(self, app, base_context):
        '''If all is good and the FIS-Broker service returns a record,
           return an HTTP 200.'''

        fb_dataset_dict, source, job = self._harvester_setup(FISBROKER_HARVESTER_CONFIG)
        package_id = fb_dataset_dict['id']
        package = Package.get(package_id)
        old_title = package.title
        response = app.get(
            url=f"/api/harvest/reimport?id={package_id}",
            headers={'Accept': 'application/json'},
            extra_environ={'REMOTE_USER': base_context['user'].encode('ascii')},
            status=200,
        )
        # assert success marker in resonse JSON
        assert response.is_json
        assert response.json['success']
        # assert that title has changed to the correct value (i.e., the reimport has actually happened)
        assert package.title == "NÃ¤hrstoffversorgung des Oberbodens 2015 (Umweltatlas) - [WFS]"
        assert package.title != old_title

    def test_reimport_anonymously_fails(self, app, base_context):
        '''Only a logged in user can initiate a successful reimport, so anonymous access
           should raise an authorization error.'''

        fb_dataset_dict, source, job = self._harvester_setup(FISBROKER_HARVESTER_CONFIG)
        job.status = 'Finished'
        job.save()
        package_update(base_context, fb_dataset_dict)
        package_id = fb_dataset_dict['id']

        with pytest.raises(NotAuthorized):
            app.get(
                url=f'/dataset/{package_id}/reimport',
                headers={'Accept': 'text/html'},
            )

    def test_reimport_invalid_dataset_triggers_deletion(self, app, base_context):
        """If a previously harvested dataset is reimported, and the
           reimport results in an ERROR_DURING_IMPORT, the package should
           have its state changed to deleted."""
        fb_dataset_dict, source, job = self._harvester_setup(
            FISBROKER_HARVESTER_CONFIG, fb_guid=INVALID_GUID)
        job.status = 'Finished'
        job.save()
        package_update(base_context, fb_dataset_dict)
        package_id = fb_dataset_dict['id']

        response = app.get(
            url=f"/api/harvest/reimport?id={package_id}",
            headers={'Accept': 'application/json'},
            extra_environ={'REMOTE_USER': base_context['user'].encode('ascii')},
            status=200,
        )

        # assert failure marker in response JSON
        assert response.is_json
        assert not response.json['success']
        assert response.json['error']['code'] == fb_exceptions.ERROR_DURING_IMPORT

        # assert that the package has indeed been deleted (deactivated)
        package = Package.get(package_id)
        assert package.state == 'deleted'

    def test_reimport_batch_raise_error_if_no_fb_havester_defined(self, app, base_context):
        '''Calling reimport_batch when there is not FIS-Broker harvester
           defined should result in an error.'''

        package_ids = []
        with pytest.raises(fb_exceptions.NoFBHarvesterDefined):
            blueprint.reimport_batch(package_ids, base_context)

    def test_reimport_batch_raise_error_for_nonexisting_package(self, app, base_context):
        '''A batch reimport containing a package_id which doesn't exist should
           trigger a PackageIdDoesNotExistError.'''

        # FIS-Broker harvester needs to exist, or reimport won't work
        self._create_source()

        package_ids = ['dunk']
        with pytest.raises(fb_exceptions.PackageIdDoesNotExistError):
            blueprint.reimport_batch(package_ids, base_context)

    def test_reimport_batch_raise_error_for_nonharvested_package(self, app, base_context):
        '''A batch reimport containing a package which wasn't harvested should
           trigger a PackageNotHarvestedError.'''

        # FIS-Broker harvester needs to exist, or reimport won't work
        self._create_source()

        non_fb_dataset_dict = ckan_factories.Dataset()
        package_id = non_fb_dataset_dict['id']

        package_ids = [package_id]
        with pytest.raises(fb_exceptions.PackageNotHarvestedError):
            blueprint.reimport_batch(package_ids, base_context)

    def test_reimport_batch_raise_error_for_package_not_harvested_by_fbharvester(self, app, base_context):
        '''A batch reimport containing a package which wasn't harvested by ckanext-fisbroker
           should trigger a PackageNotHarvestedInFisbrokerError.'''

        # FIS-Broker harvester needs to exist, or reimport won't work
        self._create_source()

        harvester_config = {
            'title': 'Dummy Harvester',
            'name': 'dummy-harvester',
            'source_type': 'dummyharvest',
            'url': "http://test.org/csw"
        }
        dataset_dict, source, job = self._harvester_setup(harvester_config)
        package_id = dataset_dict['id']

        package_ids = [package_id]
        with pytest.raises(fb_exceptions.PackageNotHarvestedInFisbrokerError):
            blueprint.reimport_batch(package_ids, base_context)

    def test_reimport_batch_raise_error_for_package_without_fb_guid(self, app, base_context):
        '''A batch reimport containing a package which doesn't have a FIS-Broker guid
           should trigger a NoFisbrokerIdError.'''

        fb_dataset_dict, source, job = self._harvester_setup(
            FISBROKER_HARVESTER_CONFIG, fb_guid=None)
        # datasets created in this way have no extras set, so also no 'guid'
        package_id = fb_dataset_dict['id']

        package_ids = [package_id]
        with pytest.raises(fb_exceptions.NoFisbrokerIdError):
            blueprint.reimport_batch(package_ids, base_context)

    def test_reimport_batch_raises_no_connection_error(self, app, base_context):
        '''A batch reimport show trigger a NoConnectionError if a connection to
           FIS-Broker cannot be established.'''

        unreachable_config = {
            'title': 'Unreachable FIS-Broker Harvest Source',
            'name': 'unreachable-fis-broker-harvest-source',
            'source_type': HARVESTER_ID,
            'url': "http://somewhere.over.the.ra.invalid/csw"
        }
        fb_dataset_dict, source, job = self._harvester_setup(unreachable_config)
        package_update(base_context, fb_dataset_dict)
        package_id = fb_dataset_dict['id']

        package_ids = [package_id]
        with pytest.raises(fb_exceptions.NoConnectionError):
            blueprint.reimport_batch(package_ids, base_context)

    def test_raise_error_for_failed_getrecordbyid_request(self, app, base_context):
        '''A reimport should fail with a NoConnectionError when the
           getrecordbyid-Request failed with a timeout.'''

        fb_dataset_dict, source, job = self._harvester_setup(
            FISBROKER_HARVESTER_CONFIG, fb_guid='cannot_connect')
        package_update(base_context, fb_dataset_dict)
        package_id = fb_dataset_dict['id']

        package_ids = [package_id]
        with pytest.raises(fb_exceptions.NoConnectionError):
            blueprint.reimport_batch(package_ids, base_context)

class DummyHarvester(SingletonPlugin):
    '''A dummy harvester for testing purposes.'''

    implements(IHarvester, inherit=True)

    def info(self):
        '''Implements ckanext.harvest.interfaces.IHarvester.info()'''

        return {
            'name': 'dummyharvest',
            'title': 'Dummy Harvester',
            'description': 'A dummy harvester for testing.'
        }
